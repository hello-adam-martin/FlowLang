"""
FlowLang Scaffolder - Automatically generate task stubs from flow definitions

This tool implements a TDD-style approach: Define your flow first in YAML,
then implement tasks one by one with automatic progress tracking.
"""

import yaml
import os
import re
from pathlib import Path
from typing import Dict, List, Set, Any
from dataclasses import dataclass, field
from datetime import datetime


@dataclass
class TaskInfo:
    """Information about a task extracted from a flow"""
    name: str
    inputs: Set[str] = field(default_factory=set)
    step_ids: List[str] = field(default_factory=list)
    is_implemented: bool = False


class FlowScaffolder:
    """Generates task stubs, tests, and documentation from flow definitions"""

    def __init__(self, output_dir: str = "."):
        self.output_dir = Path(output_dir)
        self.tasks: Dict[str, TaskInfo] = {}
        self.flow_name = "UnnamedFlow"

    def analyze_flow(self, flow_yaml: str) -> Dict[str, TaskInfo]:
        """
        Parse flow and extract all required tasks.

        Args:
            flow_yaml: YAML string containing flow definition

        Returns:
            Dictionary mapping task names to TaskInfo objects
        """
        flow_def = yaml.safe_load(flow_yaml)
        self.flow_name = flow_def.get('flow', 'UnnamedFlow')

        print(f"üìä Analyzing flow: {self.flow_name}")
        print("="*60)

        # Extract tasks from steps
        steps = flow_def.get('steps', [])
        self._extract_tasks_from_steps(steps)

        print(f"\n‚úì Found {len(self.tasks)} unique tasks")
        for task_name, task_info in sorted(self.tasks.items()):
            print(f"  - {task_name} (used {len(task_info.step_ids)} times)")

        return self.tasks

    def _extract_tasks_from_steps(self, steps: List[Dict], depth: int = 0):
        """Recursively extract tasks from step definitions"""
        for step in steps:
            # Direct task
            if 'task' in step:
                task_name = step['task']
                step_id = step.get('id', task_name)
                inputs = set(step.get('inputs', {}).keys())

                if task_name not in self.tasks:
                    self.tasks[task_name] = TaskInfo(
                        name=task_name,
                        inputs=inputs,
                        step_ids=[step_id]
                    )
                else:
                    # Task used multiple times, track all step IDs
                    self.tasks[task_name].step_ids.append(step_id)
                    # Merge inputs (union of all inputs across uses)
                    self.tasks[task_name].inputs.update(inputs)

            # Parallel steps
            elif 'parallel' in step:
                self._extract_tasks_from_steps(step['parallel'], depth + 1)

            # Conditional steps (both 'condition' and 'if' syntax)
            elif 'condition' in step or 'if' in step:
                condition = step.get('condition', step)
                if 'then' in condition:
                    self._extract_tasks_from_steps(condition['then'], depth + 1)
                if 'else' in condition:
                    self._extract_tasks_from_steps(condition['else'], depth + 1)

            # Loop steps (both 'loop' and 'for_each' syntax)
            elif 'loop' in step or 'for_each' in step:
                loop = step.get('loop', step)
                if 'do' in loop:
                    self._extract_tasks_from_steps(loop['do'], depth + 1)

    def generate_task_stubs(self, filename: str = "tasks.py") -> str:
        """
        Generate Python file with task stubs.

        Args:
            filename: Name of the output file

        Returns:
            Path to the generated file
        """
        output_path = self.output_dir / filename

        print(f"\nüìù Generating task stubs: {output_path}")

        code = self._generate_stubs_code()

        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(code)

        print(f"‚úì Generated {len(self.tasks)} task stubs")
        return str(output_path)

    def _generate_stubs_code(self) -> str:
        """Generate the Python code for task stubs"""
        lines = [
            '"""',
            f'Task implementations for {self.flow_name}',
            f'Auto-generated by FlowLang Scaffolder on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}',
            '',
            'Status: All tasks are STUBS - implement them one by one!',
            '',
            'To implement a task:',
            '1. Find the task function below',
            '2. Remove the NotImplementedTaskError',
            '3. Add your implementation',
            '4. Update the implementation status in get_implementation_status()',
            '5. Run tests: pytest test_tasks.py',
            '"""',
            '',
            'import asyncio',
            'from typing import Dict, Any',
            'from pathlib import Path',
            'import sys',
            '',
            '# Add src to path for imports',
            'sys.path.insert(0, str(Path(__file__).parent.parent / "src"))',
            '',
            'from flowlang import TaskRegistry',
            'from flowlang.exceptions import NotImplementedTaskError',
            '',
            '',
            'def create_task_registry() -> TaskRegistry:',
            '    """Create and populate the task registry with all tasks"""',
            '    registry = TaskRegistry()',
            '    ',
            '    # ========================================================================',
            '    # TASK IMPLEMENTATIONS',
            f'    # Total: {len(self.tasks)} tasks',
            '    # Status: 0 implemented, {} pending'.format(len(self.tasks)),
            '    # ========================================================================',
            '    ',
        ]

        # Generate stub for each task
        for task_name, task_info in sorted(self.tasks.items()):
            lines.extend(self._generate_task_stub(task_name, task_info))

        lines.extend([
            '',
            '    return registry',
            '',
            '',
            '# ========================================================================',
            '# IMPLEMENTATION TRACKER',
            '# ========================================================================',
            '',
            'def get_implementation_status() -> Dict[str, Any]:',
            '    """',
            '    Get status of task implementations.',
            '    ',
            '    Update this as you implement tasks:',
            '    Change False to True for each completed task.',
            '    """',
            '    tasks = {',
        ])

        for task_name in sorted(self.tasks.keys()):
            lines.append(f"        '{task_name}': False,  # TODO: Set to True when implemented")

        lines.extend([
            '    }',
            '    ',
            '    implemented = sum(1 for v in tasks.values() if v)',
            '    total = len(tasks)',
            '    ',
            '    return {',
            "        'total': total,",
            "        'implemented': implemented,",
            "        'pending': total - implemented,",
            "        'progress': f'{implemented}/{total}',",
            "        'percentage': (implemented / total * 100) if total > 0 else 0,",
            "        'tasks': tasks",
            '    }',
            '',
            '',
            'def print_status():',
            '    """Print implementation status to console"""',
            '    status = get_implementation_status()',
            '    print("="*60)',
            f'    print(f"üìä {self.flow_name} - Task Implementation Status")',
            '    print("="*60)',
            '    print(f"Total Tasks: {status[\'total\']}")',
            '    print(f"Implemented: {status[\'implemented\']} ‚úÖ")',
            '    print(f"Pending: {status[\'pending\']} ‚ö†Ô∏è")',
            '    print(f"Progress: {status[\'progress\']} ({status[\'percentage\']:.1f}%)")',
            '    print("="*60)',
            '    ',
            '    if status[\'pending\'] > 0:',
            '        print("\\n‚ö†Ô∏è  Pending Tasks:")',
            '        for task, implemented in sorted(status[\'tasks\'].items()):',
            '            if not implemented:',
            '                print(f"  [ ] {task}")',
            '    ',
            '    if status[\'implemented\'] > 0:',
            '        print("\\n‚úÖ Implemented Tasks:")',
            '        for task, implemented in sorted(status[\'tasks\'].items()):',
            '            if implemented:',
            '                print(f"  [‚úì] {task}")',
            '    ',
            '    print()',
            '',
            '',
            'if __name__ == \'__main__\':',
            '    print_status()',
        ])

        return '\n'.join(lines)

    def _generate_task_stub(self, task_name: str, task_info: TaskInfo) -> List[str]:
        """Generate stub code for a single task"""
        # Determine if task should be async based on name patterns
        async_patterns = [
            'send', 'fetch', 'get', 'post', 'put', 'delete',
            'process', 'create', 'update', 'call', 'query',
            'read', 'write', 'check', 'validate', 'calculate'
        ]
        is_async = any(word in task_name.lower() for word in async_patterns)

        async_prefix = 'async ' if is_async else ''

        # Generate parameter list
        if task_info.inputs:
            params = ', '.join(sorted(task_info.inputs))
        else:
            params = '**kwargs'

        # Generate docstring with usage info
        usage_info = f"Used in steps: {', '.join(task_info.step_ids[:3])}"
        if len(task_info.step_ids) > 3:
            usage_info += f" (+{len(task_info.step_ids) - 3} more)"

        func_name = self._to_snake_case(task_name)

        lines = [
            f"    @registry.register('{task_name}', description='TODO: Add description')",
            f"    {async_prefix}def {func_name}({params}):",
            f'        """',
            f'        {task_name} - TODO: Add detailed description',
            f'        ',
            f'        {usage_info}',
            f'        ',
        ]

        if task_info.inputs:
            lines.append(f'        Args:')
            for inp in sorted(task_info.inputs):
                lines.append(f'            {inp}: TODO: Describe this parameter')
            lines.append('        ')

        lines.extend([
            f'        Returns:',
            f'            Dict containing task results',
            f'        ',
            f'        Raises:',
            f'            NotImplementedTaskError: This task is not yet implemented',
            f'        """',
            f'        # TODO: Implement this task',
            f'        # ',
            f'        # Example implementation:',
            f'        # result = do_something({params})',
            f'        # return {{"result": result}}',
            f'        ',
            f'        raise NotImplementedTaskError("{task_name}")',
            f'    ',
        ])

        return lines

    def _to_snake_case(self, name: str) -> str:
        """Convert PascalCase/camelCase to snake_case"""
        # Insert underscore before uppercase letters
        s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
        # Insert underscore before uppercase letters preceded by lowercase
        return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()

    def generate_tests(self, filename: str = "test_tasks.py") -> str:
        """
        Generate test file for all tasks.

        Args:
            filename: Name of the output file

        Returns:
            Path to the generated file
        """
        output_path = self.output_dir / filename

        print(f"\nüß™ Generating test stubs: {output_path}")

        code = self._generate_tests_code()

        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(code)

        print(f"‚úì Generated tests for {len(self.tasks)} tasks")
        return str(output_path)

    def _generate_tests_code(self) -> str:
        """Generate test code"""
        lines = [
            '"""',
            f'Tests for {self.flow_name} tasks',
            f'Auto-generated by FlowLang Scaffolder on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}',
            '',
            'Initially, all tests expect NotImplementedTaskError.',
            'As you implement tasks, update the tests to verify actual behavior.',
            '"""',
            '',
            'import pytest',
            'import asyncio',
            'from tasks import create_task_registry',
            'from flowlang.exceptions import NotImplementedTaskError',
            '',
            '',
            '@pytest.fixture',
            'def registry():',
            '    """Fixture providing task registry"""',
            '    return create_task_registry()',
            '',
            '',
            '# ========================================================================',
            '# TASK TESTS',
            '# ========================================================================',
            '',
        ]

        for task_name, task_info in sorted(self.tasks.items()):
            lines.extend(self._generate_task_test(task_name, task_info))

        lines.extend([
            '',
            '# ========================================================================',
            '# INTEGRATION TESTS',
            '# ========================================================================',
            '',
            'def test_all_tasks_registered(registry):',
            '    """Verify all tasks are registered"""',
            '    expected_tasks = [',
        ])

        for task_name in sorted(self.tasks.keys()):
            lines.append(f"        '{task_name}',")

        lines.extend([
            '    ]',
            '    ',
            '    for task in expected_tasks:',
            '        assert registry.has_task(task), f"Task {task} not registered"',
            '',
            '',
            'def test_implementation_progress(registry):',
            '    """Track implementation progress"""',
            '    from tasks import get_implementation_status',
            '    ',
            '    status = get_implementation_status()',
            '    print(f"\\nImplementation progress: {status[\'progress\']} ({status[\'percentage\']:.1f}%)")',
            '    ',
            '    # This test always passes but shows progress',
            '    assert status[\'total\'] > 0',
            '',
            '',
            'if __name__ == \'__main__\':',
            '    pytest.main([__file__, \'-v\'])',
        ])

        return '\n'.join(lines)

    def _generate_task_test(self, task_name: str, task_info: TaskInfo) -> List[str]:
        """Generate test for a single task"""
        async_patterns = [
            'send', 'fetch', 'get', 'post', 'put', 'delete',
            'process', 'create', 'update', 'call', 'query',
            'read', 'write', 'check', 'validate', 'calculate'
        ]
        is_async = any(word in task_name.lower() for word in async_patterns)

        test_decorator = '@pytest.mark.asyncio\n' if is_async else ''
        async_prefix = 'async ' if is_async else ''
        await_prefix = 'await ' if is_async else ''

        func_name = self._to_snake_case(task_name)

        # Generate sample inputs
        sample_inputs = {}
        for inp in sorted(task_info.inputs):
            inp_lower = inp.lower()
            if 'email' in inp_lower:
                sample_inputs[inp] = 'test@example.com'
            elif 'name' in inp_lower:
                sample_inputs[inp] = 'Test Name'
            elif 'id' in inp_lower:
                sample_inputs[inp] = 'test_id_123'
            elif 'amount' in inp_lower or 'price' in inp_lower:
                sample_inputs[inp] = 100.0
            elif 'date' in inp_lower:
                sample_inputs[inp] = '2025-01-01'
            elif 'url' in inp_lower:
                sample_inputs[inp] = 'https://example.com'
            elif 'count' in inp_lower or 'num' in inp_lower:
                sample_inputs[inp] = 10
            else:
                sample_inputs[inp] = 'test_value'

        inputs_str = ', '.join(f'{k}={repr(v)}' for k, v in sample_inputs.items())

        lines = [
            f'{test_decorator}{async_prefix}def test_{func_name}(registry):',
            f'    """',
            f'    Test {task_name} task',
            f'    ',
            f'    TODO: After implementing the task, update this test to verify:',
            f'    - Correct output structure',
            f'    - Expected values',
            f'    - Error handling',
            f'    """',
            f'    # Get the task',
            f'    task = registry.get_task(\'{task_name}\')',
            f'    ',
            f'    # Currently expecting NotImplementedTaskError',
            f'    with pytest.raises(NotImplementedTaskError):',
        ]

        if is_async:
            lines.append(f'        {await_prefix}task({inputs_str})')
        else:
            lines.append(f'        task({inputs_str})')

        lines.extend([
            f'    ',
            f'    # TODO: After implementing, replace above with actual assertions:',
            f'    # result = {await_prefix}task({inputs_str})',
            f'    # assert isinstance(result, dict)',
            f'    # assert "expected_key" in result',
            f'    # assert result["expected_key"] == expected_value',
            '',
        ])

        return lines

    def generate_readme(self, filename: str = "README.md") -> str:
        """
        Generate README with implementation guide.

        Args:
            filename: Name of the output file

        Returns:
            Path to the generated file
        """
        output_path = self.output_dir / filename

        print(f"\nüìñ Generating README: {output_path}")

        content = f"""# {self.flow_name} - Implementation Guide

Auto-generated by FlowLang Scaffolder on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Overview

This project contains a flow definition and scaffolded task implementations. All tasks are currently **stubs** that need to be implemented.

## Project Structure

```
.
‚îú‚îÄ‚îÄ flow.yaml           # Flow definition (your design)
‚îú‚îÄ‚îÄ tasks.py            # Task implementations (TODO: implement these)
‚îú‚îÄ‚îÄ test_tasks.py       # Unit tests for tasks
‚îî‚îÄ‚îÄ README.md           # This file
```

## Implementation Status

- **Total tasks**: {len(self.tasks)}
- **Implemented**: 0
- **Pending**: {len(self.tasks)}
- **Progress**: 0/{len(self.tasks)} (0.0%)

## Quick Start

### 1. Check Current Status

```bash
python tasks.py
```

This shows which tasks are pending implementation.

### 2. Implement Tasks One by One

Each task in `tasks.py` currently raises `NotImplementedTaskError`. Implement them incrementally:

```python
@registry.register('TaskName')
async def task_name(param1, param2):
    # Remove this line:
    # raise NotImplementedTaskError("TaskName")

    # Add your implementation:
    result = do_something(param1, param2)

    return {{
        'output_key': result
    }}
```

### 3. Update Implementation Status

After implementing a task, update `get_implementation_status()` in `tasks.py`:

```python
def get_implementation_status() -> Dict[str, Any]:
    tasks = {{
        'TaskName': True,  # ‚Üê Changed from False to True
        ...
    }}
```

### 4. Run Tests

```bash
# Run all tests
pytest test_tasks.py -v

# Run specific test
pytest test_tasks.py::test_task_name -v
```

Update tests to verify actual behavior instead of expecting `NotImplementedTaskError`.

### 5. Run the Complete Flow

Once all tasks are implemented:

```python
import asyncio
from flowlang import FlowExecutor
from tasks import create_task_registry

async def main():
    # Load flow
    with open('flow.yaml') as f:
        flow_yaml = f.read()

    # Create executor
    registry = create_task_registry()
    executor = FlowExecutor(registry)

    # Execute flow
    result = await executor.execute_flow(
        flow_yaml,
        inputs={{
            # Your flow inputs here
        }}
    )

    print(f"Success: {{result['success']}}")
    print(f"Outputs: {{result['outputs']}}")

if __name__ == '__main__':
    asyncio.run(main())
```

## Task List

"""

        for i, (task_name, task_info) in enumerate(sorted(self.tasks.items()), 1):
            content += f"\n### {i}. {task_name}\n\n"
            content += f"- **Status**: ‚ö†Ô∏è Not implemented\n"
            content += f"- **Function**: `{self._to_snake_case(task_name)}`\n"
            content += f"- **Used in**: {', '.join(task_info.step_ids[:3])}"
            if len(task_info.step_ids) > 3:
                content += f" (+{len(task_info.step_ids) - 3} more)"
            content += "\n"
            if task_info.inputs:
                content += f"- **Inputs**: `{', '.join(sorted(task_info.inputs))}`\n"
            content += "\n"

        content += """
## Development Tips

1. **Start with simple tasks** - Implement logging, validation tasks first
2. **Use TDD approach** - Write/update tests as you implement
3. **Check progress frequently** - Run `python tasks.py` to see status
4. **Test incrementally** - Test each task as you complete it
5. **Mock external dependencies** - Use mock data initially, integrate real APIs later

## Testing Strategy

- **Unit tests**: Test each task in isolation (test_tasks.py)
- **Integration tests**: Test the complete flow execution
- **Use fixtures**: Create reusable test data
- **Mock external calls**: Don't depend on external services in tests

## Next Steps

- [ ] Implement all task stubs
- [ ] Write comprehensive tests
- [ ] Integrate with external APIs/databases
- [ ] Add error handling and retries
- [ ] Add logging and monitoring
- [ ] Deploy to production

## Getting Help

- FlowLang documentation: See CLAUDE.md
- Flow syntax: Check flow.yaml for examples
- Task registry: See src/flowlang/registry.py

Good luck! üöÄ
"""

        with open(output_path, 'w') as f:
            f.write(content)

        print(f"‚úì Generated README")
        return str(output_path)

    def scaffold(self, flow_yaml: str, output_dir: str = None):
        """
        Complete scaffolding: analyze flow and generate all files.

        Args:
            flow_yaml: YAML string containing flow definition
            output_dir: Directory to output files (uses self.output_dir if None)
        """
        if output_dir:
            self.output_dir = Path(output_dir)

        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Save flow definition
        flow_path = self.output_dir / 'flow.yaml'
        with open(flow_path, 'w') as f:
            f.write(flow_yaml)
        print(f"üíæ Saved flow definition: {flow_path}")

        # Analyze and generate
        self.analyze_flow(flow_yaml)
        self.generate_task_stubs()
        self.generate_tests()
        self.generate_readme()

        print("\n" + "="*60)
        print("üéâ Scaffolding complete!")
        print("="*60)
        print(f"üìÅ Output directory: {self.output_dir.absolute()}")
        print(f"\nüìã Next steps:")
        print(f"  1. cd {self.output_dir}")
        print(f"  2. python tasks.py          # Check implementation status")
        print(f"  3. Edit tasks.py            # Implement tasks one by one")
        print(f"  4. pytest test_tasks.py     # Run tests")
        print(f"  5. python run_flow.py       # Execute complete flow (when done)")
        print("="*60)
        print()


# ========================================================================
# CLI INTERFACE
# ========================================================================

def main():
    """CLI for scaffolding flows"""
    import argparse

    parser = argparse.ArgumentParser(
        description='FlowLang Scaffolder - Generate task stubs from flow definitions',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Scaffold a flow
  python -m flowlang.scaffolder my_flow.yaml -o ./my_project

  # Scaffold to current directory
  python -m flowlang.scaffolder my_flow.yaml -o .

For more information, see: https://github.com/hello-adam-martin/FlowLang
        """
    )
    parser.add_argument(
        'flow_file',
        help='Path to flow YAML file'
    )
    parser.add_argument(
        '-o', '--output',
        default='./flow_project',
        help='Output directory (default: ./flow_project)'
    )

    args = parser.parse_args()

    # Read flow file
    try:
        with open(args.flow_file, 'r') as f:
            flow_yaml = f.read()
    except FileNotFoundError:
        print(f"‚ùå Error: Flow file not found: {args.flow_file}")
        return 1
    except Exception as e:
        print(f"‚ùå Error reading flow file: {e}")
        return 1

    # Scaffold
    try:
        scaffolder = FlowScaffolder()
        scaffolder.scaffold(flow_yaml, args.output)
        return 0
    except Exception as e:
        print(f"‚ùå Error during scaffolding: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    exit(main())
