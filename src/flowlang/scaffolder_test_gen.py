"""
Temporary file to hold the complete _generate_tests_code method.
This will be used to replace the incomplete one in scaffolder.py.
"""

def _generate_tests_code(self) -> str:
    """Generate test code using FlowTest framework"""
    lines = [
        '"""',
        f'Tests for {self.flow_name}',
        f'Auto-generated by FlowLang Scaffolder on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}',
        '',
        'This test file uses the FlowTest framework for flow testing.',
        'FlowTest provides:',
        '  - Flow execution with load_flow() and execute_flow()',
        '  - Task mocking with mock_task()',
        '  - Assertion helpers (assert_success, assert_output_equals, etc.)',
        '  - Call tracking (assert_task_called, get_task_call_args, etc.)',
        '',
        'See: https://github.com/hello-adam-martin/FlowLang/docs/testing.md',
        '"""',
        '',
        'import pytest',
        'import sys',
        'from pathlib import Path',
        '',
        '# Add parent directory to path for flow module import',
        'sys.path.insert(0, str(Path(__file__).parent.parent))',
        '',
        'from flowlang.testing import FlowTest',
        'from flowlang.exceptions import NotImplementedTaskError',
        '',
        '',
        '# ========================================================================',
        '# FLOW TESTS',
        '# ========================================================================',
        '',
        f'class Test{self._to_pascal_case(self.flow_name)}(FlowTest):',
        '    """',
        f'    Test suite for {self.flow_name} flow',
        '    ',
        '    This class uses FlowTest to test the complete flow execution.',
        '    You can test with real tasks or mock specific tasks for isolated testing.',
        '    """',
        '    ',
        '    flow_path = str(Path(__file__).parent.parent / "flow.yaml")',
        '    tasks_file = str(Path(__file__).parent.parent / "flow.py")',
        '    ',
        '    @pytest.mark.asyncio',
        '    async def test_flow_with_mocked_tasks(self):',
        '        """',
        '        Test flow execution with all tasks mocked',
        '        ',
        '        This test verifies the flow structure without requiring',
        '        task implementations. Update this as you implement tasks.',
        '        """',
        '        await self.setup_method()',
        '        ',
        '        # Mock all tasks to avoid NotImplementedTaskError',
    ]

    # Add mock for each task
    for task_name in sorted(self.tasks.keys()):
        lines.append(f"        self.mock_task('{task_name}', return_value={{'output': 'mocked_output'}})")

    lines.extend([
        '        ',
        '        # TODO: Update test inputs based on your flow definition',
        '        inputs = {}  # Add your flow inputs here',
        '        ',
        '        # Execute flow',
        '        result = await self.execute_flow(inputs)',
        '        ',
        '        # Verify flow executed successfully',
        '        self.assert_success(result)',
        '        ',
        '        # TODO: Add assertions for specific outputs',
        '        # self.assert_output_equals(result, "output_key", "expected_value")',
        '        ',
        '        # Verify tasks were called',
    ])

    # Add task call assertions
    for task_name in sorted(self.tasks.keys()):
        lines.append(f"        # self.assert_task_called('{task_name}', times=1)")

    lines.extend([
        '    ',
        '    @pytest.mark.skip(reason="Remove this skip when tasks are implemented")',
        '    @pytest.mark.asyncio',
        '    async def test_flow_with_real_tasks(self):',
        '        """',
        '        Test flow execution with real task implementations',
        '        ',
        '        Remove the @pytest.mark.skip decorator once tasks are implemented.',
        '        This test runs the actual flow without mocks.',
        '        """',
        '        await self.setup_method()',
        '        ',
        '        # TODO: Update test inputs based on your flow definition',
        '        inputs = {',
        '            # Add your flow inputs here',
        '        }',
        '        ',
        '        # Execute flow with real tasks',
        '        result = await self.execute_flow(inputs)',
        '        ',
        '        # Verify success',
        '        self.assert_success(result)',
        '        ',
        '        # TODO: Add specific output assertions',
        '        # self.assert_output_equals(result, "result_key", "expected_value")',
        '        # self.assert_output_contains(result, "message", "expected substring")',
        '        ',
        '        # Check execution time if needed',
        '        # self.assert_execution_time_under(5.0)  # seconds',
        '    ',
        '    @pytest.mark.asyncio',
        '    async def test_flow_with_partial_mocking(self):',
        '        """',
        '        Example: Test flow with some tasks real and some mocked',
        '        ',
        '        This pattern is useful when you want to test specific tasks',
        '        while mocking external dependencies.',
        '        """',
        '        await self.setup_method()',
        '        ',
        '        # Mock only external/expensive tasks',
        '        # Example:',
        '        # self.mock_task("SendEmail", return_value={"sent": True})',
        '        # self.mock_task("CallExternalAPI", return_value={"data": "mocked"})',
        '        ',
        '        # Skip this test for now',
        '        pytest.skip("Remove this skip and add your partial mocking logic")',
        '',
        '',
        '# ========================================================================',
        '# REGISTRY TESTS (LEGACY)',
        '# These tests use the older registry-based approach',
        '# Consider migrating to FlowTest-based tests above',
        '# ========================================================================',
        '',
        '@pytest.fixture',
        'def registry():',
        '    """Fixture providing task registry"""',
        '    from flow import create_task_registry',
        '    return create_task_registry()',
        '',
        '',
        'def test_all_tasks_registered(registry):',
        '    """Verify all tasks are registered"""',
        '    expected_tasks = [',
    ])

    for task_name in sorted(self.tasks.keys()):
        lines.append(f"        '{task_name}',")

    lines.extend([
        '    ]',
        '    ',
        '    for task in expected_tasks:',
        '        assert registry.has_task(task), f"Task {task} not registered"',
        '',
        '',
        'def test_implementation_progress(registry):',
        '    """Track implementation progress"""',
        '    from flow import get_implementation_status',
        '    ',
        '    status = get_implementation_status()',
        '    print(f"\\nImplementation progress: {status[\'progress\']} ({status[\'percentage\']:.1f}%)")',
        '    ',
        '    # This test always passes but shows progress',
        '    assert status[\'total\'] > 0',
        '',
        '',
        'if __name__ == \'__main__\':',
        '    pytest.main([__file__, \'-v\'])',
    ])

    return '\n'.join(lines)
