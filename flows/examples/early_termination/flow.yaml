flow: EarlyTerminationPatterns
description: |
  Demonstrates different patterns for handling early termination in flows.
  Shows best practices for "stop processing if condition fails" scenarios.

inputs:
  - name: user_id
    type: string
    required: true

steps:
  # Fetch data first
  - task: FetchUserData
    id: user
    inputs:
      user_id: ${inputs.user_id}
    outputs:
      - status
      - verified
      - age

  # ========================================================================
  # PATTERN 1: Single Gate Pattern (Recommended for simple cases)
  # Everything else nested inside the "passed" condition
  # ========================================================================
  - if: ${user.status} == "active"
    then:
      # All subsequent processing happens here
      - task: ProcessActiveUser
        id: process_result
        inputs:
          user_id: ${inputs.user_id}

      - task: SendConfirmation
        id: confirmation
        inputs:
          user_id: ${inputs.user_id}

      - task: RecordSuccess
        id: final_result
        inputs:
          user_id: ${inputs.user_id}
          outcome: "success"
        outputs:
          - result_id
    else:
      # Rejection path - stops here
      - task: RejectInactiveUser
        id: rejection
        inputs:
          user_id: ${inputs.user_id}

      - task: RecordRejection
        id: final_result
        inputs:
          user_id: ${inputs.user_id}
          outcome: "rejected"
        outputs:
          - result_id

  # ========================================================================
  # PATTERN 2: Multi-Stage Gates (For complex flows)
  # Each stage checks if previous stage succeeded
  # ========================================================================

  # Stage 1: Initial validation
  - if:
      all:
        - ${user.verified} == true
        - ${user.age} >= 18
    then:
      - task: PerformStage1
        id: stage1
        inputs:
          user_id: ${inputs.user_id}
        outputs:
          - stage1_passed
          - stage1_data

      # Stage 2: Only runs if stage 1 succeeded
      - if: ${stage1.stage1_passed} == true
        then:
          - task: PerformStage2
            id: stage2
            inputs:
              user_id: ${inputs.user_id}
              stage1_data: ${stage1.stage1_data}
            outputs:
              - stage2_passed
              - stage2_data

          # Stage 3: Only runs if stage 2 succeeded
          - if: ${stage2.stage2_passed} == true
            then:
              - task: PerformStage3
                id: stage3
                inputs:
                  user_id: ${inputs.user_id}
                  stage2_data: ${stage2.stage2_data}
                outputs:
                  - final_result
            else:
              - task: LogStage2Failure
                id: stage2_fail
                inputs:
                  user_id: ${inputs.user_id}
        else:
          - task: LogStage1Failure
            id: stage1_fail
            inputs:
              user_id: ${inputs.user_id}
    else:
      - task: LogInitialValidationFailure
        id: validation_fail
        inputs:
          user_id: ${inputs.user_id}

  # ========================================================================
  # PATTERN 3: Switch/Case for Multiple Terminal States
  # Use when you have multiple early exit conditions
  # ========================================================================
  - task: DetermineUserEligibility
    id: eligibility
    inputs:
      user_id: ${inputs.user_id}
    outputs:
      - eligibility_status  # "approved", "rejected", "pending", "blocked"

  - switch: ${eligibility.eligibility_status}
    cases:
      - when: "approved"
        do:
          # Full approval flow
          - task: ProcessApproval
            id: approval_result
            inputs:
              user_id: ${inputs.user_id}

          - task: SendApprovalNotification
            id: notify_approved
            inputs:
              user_id: ${inputs.user_id}

      - when: "pending"
        do:
          # Queue for manual review and stop
          - task: QueueForReview
            id: review_queued
            inputs:
              user_id: ${inputs.user_id}

          - task: SendPendingNotification
            id: notify_pending
            inputs:
              user_id: ${inputs.user_id}

      - when: "rejected"
        do:
          # Rejection path - terminates here
          - task: LogRejection
            id: log_reject
            inputs:
              user_id: ${inputs.user_id}

          - task: SendRejectionNotification
            id: notify_rejected
            inputs:
              user_id: ${inputs.user_id}

      - when: "blocked"
        do:
          # Blocked path - security notification
          - task: LogSecurityBlock
            id: log_block
            inputs:
              user_id: ${inputs.user_id}

          - task: NotifySecurityTeam
            id: notify_security
            inputs:
              user_id: ${inputs.user_id}

      - default:
          - task: LogUnknownStatus
            id: log_unknown
            inputs:
              user_id: ${inputs.user_id}

  # ========================================================================
  # PATTERN 4: Guard Clauses with Quantifiers
  # Use quantified conditions for complex early exit logic
  # ========================================================================
  - task: FetchSecurityChecks
    id: security
    inputs:
      user_id: ${inputs.user_id}
    outputs:
      - has_fraud_alert
      - has_open_disputes
      - has_payment_failures
      - account_locked

  # Only proceed if NONE of the red flags are true
  - if:
      none:
        - ${security.has_fraud_alert} == true
        - ${security.has_open_disputes} == true
        - ${security.has_payment_failures} == true
        - ${security.account_locked} == true
    then:
      # Passed all security checks - continue processing
      - task: ProcessSecureTransaction
        id: secure_process
        inputs:
          user_id: ${inputs.user_id}

      - task: UpdateSecurityLog
        id: security_log_success
        inputs:
          user_id: ${inputs.user_id}
          result: "passed"
    else:
      # Failed security check - terminate
      - task: BlockTransaction
        id: blocked
        inputs:
          user_id: ${inputs.user_id}
          security: ${security}

      - task: UpdateSecurityLog
        id: security_log_blocked
        inputs:
          user_id: ${inputs.user_id}
          result: "blocked"

  # ========================================================================
  # ANTI-PATTERN: Don't Do This!
  # ========================================================================
  # This is what the original loan_approval.yaml did - it continues
  # processing even after rejection, which is incorrect:
  #
  # - if: ${condition}
  #   then:
  #     - task: Reject
  #   else:
  #     - task: Approve
  #
  # - task: KeepProcessing  # ❌ This runs regardless of rejection!
  # - task: MoreProcessing  # ❌ This also runs after rejection!
  #
  # Instead, nest everything inside the approval path:
  #
  # - if: ${condition}
  #   then:
  #     - task: Approve
  #     - task: KeepProcessing  # ✅ Only runs if approved
  #     - task: MoreProcessing  # ✅ Only runs if approved
  #   else:
  #     - task: Reject  # ✅ Terminates here
  # ========================================================================

outputs:
  - name: final_status
    value: ${final_result.result_id}
